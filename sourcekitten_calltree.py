#! python3

#

import json
import sys
import os
import re
import argparse
import select
import textwrap
from graphviz import Digraph

# helpers


def print_list(list):
    for item in list:
        print(item)


def read_file_to_string(file_path):
    with open(file_path, "r") as file:
        return file.read()


def read_json_file(file_name):
    with open(file_name, 'r') as json_file:
        return json.load(json_file)


def drop_suffix_regex(string, pattern):
    return re.sub(pattern + "$", "", string)


def drop_suffix_parens(string):
    return re.sub("\(.*\)$", "", string)


class VisitorFuncDeclAndCall:
    """ Recognizes function declarations in visited nodes.
        Collects their names in a list.
        Recognizes function calls in visited nodes
        and collects the called functions in an array per calling function."""

    def __init__(self, exclusion_list=[], verbose=False):
        self.funcs_and_calls = {}  # dict where key: method name, value: set of callee names
        self.exclusion_list = exclusion_list
        self.stack = []
        self.verbose = verbose

    def find_declared_func(self):
        """find the last not None item in the stack"""
        for i in range(len(self.stack) - 1, -1, -1):
            if self.stack[i] is not None:
                return self.stack[i]
        return None

    def process(self, node):
        if isinstance(node, dict):
            print() if self.verbose else None
            # print("name:", drop_suffix_parens(
            #     node["key.name"]) if "key.name" in node else "None",
            #     "key.offset:", node["key.offset"])
            print("self.stack:", self.stack, "key.offset:",
                  node["key.offset"]) if self.verbose else None
            try:
                if node["key.kind"] in ["source.lang.swift.decl.function.method.instance", "source.lang.swift.decl.function.free"]:
                    # func declaration detected
                    declared_func = drop_suffix_parens(node["key.name"])
                    self.funcs_and_calls.update({declared_func: set()})
                    self.stack[-1] = declared_func
                    print("=== declare:", declared_func) if self.verbose else None
                elif node["key.kind"] == "source.lang.swift.expr.call":
                    # func call detected
                    if "key.name" in node:
                        called_func = node["key.name"]
                        calling_func = self.find_declared_func()
                        print(
                            f"--- call: {calling_func} ---> {called_func}") if self.verbose else None
                        if called_func not in self.exclusion_list:
                            self.funcs_and_calls[calling_func].add(called_func)
            except KeyError:
                # print("KeyError:", node)
                pass

    def json_compatible_result(self):
        """Converts the set of callees to a list for JSON serialization."""
        return {k: list(v) for k, v in self.funcs_and_calls.items()}

# walker


def walker(node, visitor):
    if isinstance(node, dict):
        visitor.stack.append(None)
        visitor.process(node)
        for key, value in node.items():
            walker(value, visitor)
        visitor.stack.pop()
    elif isinstance(node, list):
        for item in node:
            walker(item, visitor)
    return node

# plotter


def plotter(funcs_and_calls, basename):
    dot = Digraph(comment='')
    dot.attr("graph", ratio="0.2")
    dot.attr(size='20,12')

    for func_name, called_funcs in funcs_and_calls.items():
        dot.node(func_name, func_name, rank='source')
        for called_func in called_funcs:
            dot.edge(func_name, called_func)
    dot.render(f'graphviz-output/{basename}.calltree.gv', view=True)

# runners


def run_visitor_func_decl_and_call(top_node, exclude_list, basename):
    verbose = False
    visitor = VisitorFuncDeclAndCall(exclude_list, verbose)
    walker(top_node, visitor)
    # print("visitor:", visitor.funcs_and_calls)
    json_str = json.dumps(visitor.json_compatible_result(), indent=4)
    print(json_str)
    plotter(visitor.funcs_and_calls, basename)


def main(args):

    try:
        top_node = json.loads(args.input_text)
    except json.decoder.JSONDecodeError:
        print("JSONDecodeError: input_text is not valid JSON")
        # print("input_text:", args.input_text)
        return

    try:
        exclude_list = args.exclude.split(",")
        assert (isinstance(exclude_list, list))
    except AssertionError:
        print(f"Exclude list is malformed: {args.exclude}")
        return

    basename = os.path.basename(args.file)

    run_visitor_func_decl_and_call(top_node, exclude_list, basename)


if __name__ == '__main__':

    # parser = argparse.ArgumentParser(description='Process a file.')
    # parser.add_argument('file', type=str, help='the file to be processed')

    description = 'Process a json file generated by sourcekitten --structure and generate a calltree.'
    epilog = textwrap.dedent('''
    How to generate a calltree for a Swift file:
    1. sourcekitten structure --file <file>.swift | python3 sourcekitten_calltree.py
    2. or, in two steps:
        2.1. sourcekitten structure --file <file>.swift > <file>.json
        2.2. python3 sourcekitten_calltree.py <file>.json
    3. this script generates two calltree files in subdirectory graphviz-output/:
        3.1 <file>.calltree.gv 
        3.2 <file>.calltree.gv.pdf and opens it in Preview.
    4. if needed, install sourcekitten first: 
        brew install sourcekitten
    5. You can exclude uninteresting functions from the calltree by passing them as a comma-separated list, e.g.:
       ./sourcekitten_calltree.py --file <file>.json -x print,String,Int
    ''')

    parser = argparse.ArgumentParser(
        description=description, epilog=epilog, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('--file', type=str, help='the file to process')
    parser.add_argument('-x', '--exclude', type=str, default='',
                        help='exclude identifiers from the call tree')

    args = parser.parse_args()

    if args.file:
        with open(args.file, 'r') as f:
            args.input_text = f.read()
    else:
        timeout = 1
        ready, _, _ = select.select([sys.stdin], [], [], timeout)
        if ready:
            args.input_text = sys.stdin.read()
            args.file = "stdin"
        else:
            sys.stderr.write(
                """No input received within 1 second.
Please pipe the input to sdtdin or use the `--file <inputfile>` option.
\n""")
            sys.exit()
    main(args)
